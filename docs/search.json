[
  {
    "objectID": "lec2.html",
    "href": "lec2.html",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "",
    "text": "2.1 Session 2 — Git essentials & Git‑LFS (75 min)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#session-2-git-essentials-gitlfs-75-min",
    "href": "lec2.html#session-2-git-essentials-gitlfs-75-min",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "",
    "text": "2.1.1 Learning goals\nBy the end of class, students can:\n\nExplain Git’s mental model: working directory → staging → commit; branches and remotes.\nCreate a feature branch, commit changes, and push to GitHub from Colab safely.\nUse .gitignore to avoid committing generated artifacts and secrets.\nInstall and configure Git‑LFS, track large/binary files, and verify tracking.\nOpen a pull request (PR) and follow review etiquette.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#agenda-75-minutes",
    "href": "lec2.html#agenda-75-minutes",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.2 Agenda (75 minutes)",
    "text": "2.2 Agenda (75 minutes)\n\n(8 min) Recap & goals; overview of today’s workflow\n(12 min) Slides: Git mental model; branches; remotes; commit hygiene\n(10 min) Slides: .gitignore must‑haves; Git‑LFS (when/why); LFS quotas & pitfalls\n(35 min) In‑class lab: clone → config → branch → .gitignore → LFS → sample Parquet → push → PR\n(10 min) Wrap‑up; troubleshooting; homework briefing",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#main-points",
    "href": "lec2.html#main-points",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.3 Main points",
    "text": "2.3 Main points\n\n2.3.1 Git mental model\n\nWorking directory (your files) → git add → staging → git commit → local history\nRemote: GitHub hosts a copy. git push publishes commits; git pull brings others’ changes.\nBranch: a movable pointer to a chain of commits. Default is main. Create feature branches for each change.\n\n\n\n2.3.2 Branch & PR etiquette\n\nOne feature/change per branch (small, reviewable diffs).\nCommit messages: imperative mood, short subject line (≤ 72 chars), details in body if needed:\n\nfeat: add git-lfs tracking for parquet\ndocs: add README section on setup\nchore: ignore raw data directory\n\nPR description: what/why, testing notes, checklist. Tag your teammate for review.\n\n\n\n2.3.3 .gitignore must‑haves\n\nSecrets: .env, API keys (never commit).\nLarge/derived artifacts: raw/interim data, logs, cache, compiled assets.\nNotebooks’ checkpoints: .ipynb_checkpoints/.\nOS/editor cruft: .DS_Store, Thumbs.db, .vscode/.\n\n\n\n2.3.4 Git‑LFS\n\nGit‑LFS = Large File Storage. Keeps pointers in Git; binaries in LFS storage.\nTrack only what’s necessary to version (e.g., small processed Parquet samples, posters/PDFs, small models).\nDo not LFS huge raw data you can re‑download (make get-data).\nQuotas apply on Git hosting—be selective.\n\n\n\n2.3.5 Safe pushes from Colab\n\nUse a fine‑grained PAT limited to a single repo with Contents: Read/Write + Pull requests: Read/Write.\nEnter token via getpass (not stored). Push using a temporary URL (token not saved in git config).\nAfter push, clear cell output.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#inclass-lab-35-min",
    "href": "lec2.html#inclass-lab-35-min",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.10 In‑class lab (35 min)",
    "text": "2.10 In‑class lab (35 min)\n\nInstructor tip: Students should have created a repo on GitHub before this lab (e.g., unified-stocks-teamX). If not, give them 3 minutes to do so and add their partner as a collaborator.\n\nWe’ll:\n\nMount Drive & clone the repo.\nConfigure Git identity.\nCreate a feature branch.\nAdd .gitignore.\nInstall and configure Git‑LFS.\nTrack Parquet & DB files; generate a sample Parquet.\nCommit & push from Colab using a short‑lived PAT.\nOpen a PR (via web UI, optional API snippet included).\n\n\n2.10.1 0) Mount Google Drive and set variables\n# Colab cell\nfrom google.colab import drive\ndrive.mount('/content/drive', force_remount=True)\n\n# Adjust these two for YOUR repo\nREPO_OWNER = \"YOUR_GITHUB_USERNAME_OR_ORG\"\nREPO_NAME  = \"unified-stocks-teamX\"   # e.g., unified-stocks-team1\n\nBASE_DIR   = \"/content/drive/MyDrive/dspt25\"\nCLONE_DIR  = f\"{BASE_DIR}/{REPO_NAME}\"\nREPO_URL   = f\"https://github.com/{REPO_OWNER}/{REPO_NAME}.git\"\n\nimport os, pathlib\npathlib.Path(BASE_DIR).mkdir(parents=True, exist_ok=True)\n\n\n2.10.2 1) Clone the repo (or pull latest if already cloned)\nimport os, subprocess, shutil, pathlib\n\nif not pathlib.Path(CLONE_DIR).exists():\n    !git clone {REPO_URL} {CLONE_DIR}\nelse:\n    # If the folder exists, just ensure it's a git repo and pull latest\n    os.chdir(CLONE_DIR)\n    !git status\n    !git pull --ff-only  # ff to avoid diverged branches\nos.chdir(CLONE_DIR)\nprint(\"Working dir:\", os.getcwd())\n\n\n2.10.3 2) Configure Git identity (local to this repo)\n# Replace with your name and school email\n!git config user.name \"Your Name\"\n!git config user.email \"you@example.edu\"\n\n!git config --get user.name\n!git config --get user.email\n\n\n2.10.4 3) Create and switch to a feature branch\nBRANCH = \"setup/git-lfs\"\n!git checkout -b {BRANCH}\n!git branch --show-current\n\n\n2.10.5 4) Add a robust .gitignore\ngitignore = \"\"\"\\\n# Byte-compiled / cache\n__pycache__/\n*.py[cod]\n\n# Jupyter checkpoints\n.ipynb_checkpoints/\n\n# OS/editor files\n.DS_Store\nThumbs.db\n.vscode/\n\n# Environments & secrets\n.env\n.env.*\n.venv/\n*.pem\n*.key\n\n# Data (raw & interim never committed)\ndata/raw/\ndata/interim/\n\n# Logs & caches\nlogs/\n.cache/\n\"\"\"\nopen(\".gitignore\", \"w\").write(gitignore)\nprint(open(\".gitignore\").read())\n\n\n2.10.6 5) Install and initialize Git‑LFS (Colab)\n# Install git-lfs on the Colab VM (one-time per runtime): apt-get: advanced package tool(manager)\n!apt-get -y update &gt;/dev/null # refresh vailable packages from the repositories\n!apt-get -y install git-lfs &gt;/dev/null\n!git lfs install\n!git lfs version\n\n\n2.10.7 6) Track Parquet/DB/PDF/model binaries with LFS\n# Add .gitattributes entries via git lfs track\n!git lfs track \"data/processed/*.parquet\"\n!git lfs track \"data/*.db\"\n!git lfs track \"models/*.pt\"\n!git lfs track \"reports/*.pdf\"\n\n# Show what LFS is tracking and verify .gitattributes created\n!git lfs track\nprint(\"\\n.gitattributes:\")\nprint(open(\".gitattributes\").read())\n\nWhy not LFS for raw? Raw data should be re‑downloadable with make get-data later; don’t burn LFS quota.\n\n\n\n2.10.8 7) Create a small Parquet file to test LFS\nimport pandas as pd, numpy as np, os, pathlib\n\npathlib.Path(\"data/processed\").mkdir(parents=True, exist_ok=True)\n\ntickers = pd.read_csv(\"tickers_25.csv\")[\"ticker\"].tolist() if os.path.exists(\"tickers_25.csv\") else [\n    \"AAPL\",\"MSFT\",\"AMZN\",\"GOOGL\",\"META\",\"NVDA\",\"TSLA\",\"JPM\",\"JNJ\",\"V\",\n    \"PG\",\"HD\",\"BAC\",\"XOM\",\"CVX\",\"PFE\",\"KO\",\"DIS\",\"NFLX\",\"INTC\",\"CSCO\",\"ORCL\",\"T\",\"VZ\",\"WMT\"\n]\n\n# 1000 business days x up to 25 tickers ~ 25k rows; a few MB as Parquet\ndates = pd.bdate_range(\"2018-01-01\", periods=1000)\ndf = (pd.MultiIndex.from_product([tickers, dates], names=[\"ticker\",\"date\"])\n      .to_frame(index=False))\nrng = np.random.default_rng(42)\ndf[\"r_1d\"] = rng.normal(0, 0.01, size=len(df))  # synthetic daily returns\ndf.to_parquet(\"data/processed/sample_returns.parquet\", index=False)\ndf.head()\n\n\n2.10.9 8) Stage and commit changes\n!git add .gitignore .gitattributes data/processed/sample_returns.parquet\n!git status\n\n!git commit -m \"feat: add .gitignore and git-lfs tracking; add sample Parquet\"\n!git log --oneline -n 2  # limit to the most recent 2 commits\nIf see error “error: cannot run .git/hooks/post-commit: No such file or directory”, it means the post-commit hook is not executable or missing. ### Troubleshooting post-commit hook error 1. See what Git is trying to run\nls -l .git/hooks/post-commit\n\nIf you see -rw-r--r--, it’s not executable.\n\n\nMake it executable\n\nchmod +x .git/hooks/post-commit\n\nEnsure it has a valid shebang (first line) Open it and confirm the first line is one of:\n\nhead -n 1 .git/hooks/post-commit\n#!/bin/sh\n# or\n#!/usr/bin/env bash\n# or (if it’s Node)\n#!/usr/bin/env node\nSave if you needed to fix that.\n\nTest the hook manually\n\n.git/hooks/post-commit\n# or explicitly with the interpreter you expect, e.g.:\nbash .git/hooks/post-commit\n\n\n2.10.10 9) Push from Colab with a short‑lived token (safe method)\n\nCreate a fine‑grained PAT at GitHub → Settings → Developer settings → Fine‑grained tokens\n\nResource owner: your username/org\nRepositories: only select repositories\nPermissions: Contents (Read/Write), Pull requests (Read/Write)\nExpiration: short (e.g., 7 days)\n\n\n# Colab cell: push using a temporary URL with token (not saved to git config)\nfrom getpass import getpass\ntoken = getpass(\"Enter your GitHub token (input hidden; not stored): \")\n\npush_url = f\"https://{token}@github.com/{REPO_OWNER}/{REPO_NAME}.git\"\n!git push {push_url} {BRANCH}:{BRANCH}\n\n# Optional: immediately clear the token variable\ndel token\nIf error occurs, check:\n\n\n2.10.11 1. Check permissions\nls -l .git/hooks/pre-push\nIf it looks like -rw-r--r--, then it’s missing the executable bit. Fix:\nchmod +x .git/hooks/pre-push\n\n\n2.10.12 2. Check the first line (shebang)\nOpen it:\nhead -n 1 .git/hooks/pre-push\nYou should see something like:\n#!/bin/sh\nor\n#!/usr/bin/env bash\nIf it’s missing, add a valid shebang.\n\n\n2.10.13 3. Test the hook manually\n.git/hooks/pre-push\n# or explicitly:\nbash .git/hooks/pre-push\n\nIf the command prints the URL, clear this cell’s output after a successful push (Colab: “⋮” → “Clear output”).\n\n\n\n2.10.14 10) Open a Pull Request\nThe name “pull request” can be confusing at first — it sounds like you are “pushing” your code, but really you’re asking someone else to pull it.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#wrapup-talking-points-10-min",
    "href": "lec2.html#wrapup-talking-points-10-min",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.5 Wrap‑up (talking points, 10 min)",
    "text": "2.5 Wrap‑up (talking points, 10 min)\n\nKeep PRs small and focused; write helpful titles and descriptions.\nDon’t commit secrets or large data. Use .env + .env.example.\nUse LFS selectively—version only small, important binaries (e.g., sample processed sets, posters).\nNext time: Quarto polish (already started) and Unix automation to fetch raw data reproducibly.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#homework-due-before-session-3",
    "href": "lec2.html#homework-due-before-session-3",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.15 Homework (due before Session 3)",
    "text": "2.15 Homework (due before Session 3)\nGoal: Cement branch/PR hygiene, add review scaffolding, and add a small guard against large files accidentally committed outside LFS.\n\n2.15.1 Part A — Add a PR template and CODEOWNERS\nCreate a PR template so every PR includes key info.\n# Run in your repo root\nimport os, pathlib, textwrap\npathlib.Path(\".github\").mkdir(exist_ok=True)\ntpl = textwrap.dedent(\"\"\"\\\n    ## Summary\n    What does this PR do and why?\n\n    ## Changes\n    - \n\n    ## How to test\n    - From a fresh clone: steps to run\n\n    ## Checklist\n    - [ ] Runs from a fresh clone (README steps)\n    - [ ] No secrets committed; `.env` only (and `.env.example` updated if needed)\n    - [ ] Large artifacts tracked by LFS (`git lfs ls-files` shows expected files)\n    - [ ] Clear, small diff; comments where useful\n\"\"\")\nopen(\".github/pull_request_template.md\",\"w\").write(tpl)\nprint(\"Wrote .github/pull_request_template.md\")\n(Optional) Require both teammates to review by setting CODEOWNERS (edit handles):\nowners = \"\"\"\\\n# Replace with your GitHub handles\n* @teammate1 @teammate2\n\"\"\"\nopen(\".github/CODEOWNERS\",\"w\").write(owners)\nprint(\"Wrote .github/CODEOWNERS (edit handles!)\")\nCommit and push on a new branch (example: chore/pr-template), open a PR, and merge after review. If working on G-Drive: execute the following before git operations: chmod +x .git/hooks/*\n\n\n2.15.2 Part B — Add a large‑file guard (simple Python script)\nCreate a small tool that fails if files &gt; 10 MB are found and aren’t tracked by LFS. This will be used manually for now (automation later in CI).\n# tools/guard_large_files.py\nimport os, subprocess, sys\n\nLIMIT_MB = 10\nROOT = os.getcwd()\n\ndef lfs_tracked_paths(): #find all files tracked by lfs\n    try:\n        out = subprocess.check_output([\"git\", \"lfs\", \"ls-files\"], text=True)\n        tracked = set()\n        for line in out.strip().splitlines():\n            # line format: \"&lt;oid&gt; &lt;path&gt;\"\n            p = line.split(None, 1)[-1].strip()\n            tracked.add(os.path.normpath(p))\n        return tracked\n    except Exception:\n        return set()\n\ndef humanize(bytes_):\n    return f\"{bytes_/(1024*1024):.2f} MB\"\n\nlfs_set = lfs_tracked_paths()\nbad = []\nfor dirpath, dirnames, filenames in os.walk(ROOT):\n    # skip .git directory\n    if \".git\" in dirpath.split(os.sep):\n        continue\n    for fn in filenames:\n        path = os.path.normpath(os.path.join(dirpath, fn))\n        try:\n            size = os.path.getsize(path)\n        except FileNotFoundError:\n            continue\n        if size &gt;= LIMIT_MB * 1024 * 1024:\n            rel = os.path.relpath(path, ROOT)\n            if rel not in lfs_set:\n                bad.append((rel, size))\n\nif bad:\n    print(\"ERROR: Large non-LFS files found:\")\n    for rel, size in bad:\n        print(f\" - {rel} ({humanize(size)})\")\n    sys.exit(1)\nelse:\n    print(\"OK: No large non-LFS files detected.\")\nAdd a Makefile target to run it. Let’s generate the tools directory and the script:\n# Define the path to the tools directory\ntools_dir = Path(\"tools\")\n\n# Create it if it doesn't exist (including any parents)\ntools_dir.mkdir(parents=True, exist_ok=True)\n\nprint(f\"Directory '{tools_dir}' is ready.\")\n# Create/append Makefile target\nfrom pathlib import Path\ntext = \"\\n\\nguard:\\n\\tpython tools/guard_large_files.py\\n\" # guard: Makefile target. \\t: tab required. \np = Path(\"Makefile\") # point to the Makefile\n# p.write_text(p.read_text() + text if p.exists() else text) # if p exists, read exising content and append text and overwrites. \n# the above code will append text everytime, casue error if repeatedly excute. \nif p.exists():\n    content = p.read_text()\n    if \"guard:\" not in content:\n        p.write_text(content + text)\nelse:\n    p.write_text(text)\n\nprint(\"Added 'guard' target to Makefile\")\nAfter running the snippet: Your repo has a Makefile with a guard target. Running:\nmake guard\nwill execute your Python script:\npython tools/guard_large_files.py\nRun locally/Colab:\n!python tools/guard_large_files.py\nCommit on a new branch (e.g., chore/large-file-guard), push, open PR, and merge after review.\n\n\n2.15.3 Part C — Branch/PR practice (each student)\n\nEach student creates their own branch (e.g., docs/readme-username) and:\n\nAdds a “Development workflow” section in README.md (1–2 paragraphs): how to clone, mount Drive in Colab, install requirements, and where outputs go.\nAdds themselves to README.md “Contributors” section with a GitHub handle link.\n\nPush branch and open a PR.\nPartner reviews the PR:\n\nLeave at least 2 useful comments (nits vs blockers).\nApprove when ready; the author merges.\n\n\nExpected files touched: README.md, .github/pull_request_template.md, optional .github/CODEOWNERS, tools/guard_large_files.py, Makefile.\n\n\n2.15.4 Part D — Prove LFS is working\n\nOn main, run:\n\n!git lfs ls-files\n\nYou should see data/processed/sample_returns.parquet (and any other tracked binaries).\nIn the GitHub web UI, click the file to confirm it’s an LFS pointer, not full binary contents.\n\n\n\n2.15.5 Submission checklist (pass/revise)\n\nTwo merged PRs (template + guard) with clear titles and descriptions.\nREADME updated with development workflow and contributors.\ngit lfs ls-files shows expected files.\ntools/guard_large_files.py present and passes (OK) on main.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#instructor-checklist-before-class",
    "href": "lec2.html#instructor-checklist-before-class",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.7 Instructor checklist (before class)",
    "text": "2.7 Instructor checklist (before class)\n\nEnsure students have or can create a GitHub repo and add collaborators.\nValidate the lab sequence once in a fresh Colab runtime.\nHave example screenshots of: PR diff, LFS pointer file, successful git lfs ls-files.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#emphasize-while-teaching",
    "href": "lec2.html#emphasize-while-teaching",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.8 Emphasize while teaching",
    "text": "2.8 Emphasize while teaching\n\nSmall PRs win. Short diffs → fast, focused reviews.\nDon’t commit secrets. .env only; keep .env.example up to date.\nUse LFS sparingly and purposefully—prefer regenerating big raw data.\nColab pushes: use a short‑lived token, and clear outputs after use.\n\nNext session: Quarto reporting polish and pipeline hooks; soon after, Unix automation so make get-data can reproducibly fetch raw data for the unified‑stocks project.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#slides",
    "href": "lec2.html#slides",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.3 Slides",
    "text": "2.3 Slides\n\n2.3.1 Git mental model\n\nWorking directory (your files) → git add → staging → git commit → local history\nRemote: GitHub hosts a copy. git push publishes commits; git pull brings others’ changes.\nBranch: a movable pointer to a chain of commits. Default is main. Create feature branches for each change.\n\nIn Git, a branch is essentially just a movable pointer to a commit.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#the-simple-definition",
    "href": "lec2.html#the-simple-definition",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.4 1. The simple definition",
    "text": "2.4 1. The simple definition\n\nA branch has a name (e.g., main, feature/login).\nThat name points to a specific commit in your repository.\nAs you make new commits on that branch, the pointer moves forward.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#visual-example",
    "href": "lec2.html#visual-example",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.5 2. Visual example",
    "text": "2.5 2. Visual example\nLet’s say your repo looks like this:\nA --- B --- C   ← main\nHere:\n\nmain is the branch name.\nIt points to commit C.\n\nIf you make a new branch:\ngit branch feature\nNow you have:\nA --- B --- C   ← main, feature\nIf you checkout feature and make a commit:\nA --- B --- C   ← main\n             \\\n              D   ← feature\n\nfeature moves forward to D (new commit).\nmain stays at C.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#head-and-active-branch",
    "href": "lec2.html#head-and-active-branch",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.6 3. HEAD and active branch",
    "text": "2.6 3. HEAD and active branch\n\nHEAD is your current position — it points to the branch you’re working on.\nWhen you commit, Git moves that branch forward.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#why-branches-matter",
    "href": "lec2.html#why-branches-matter",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.7 4. Why branches matter",
    "text": "2.7 4. Why branches matter\n\nLet you work on new features, bug fixes, or experiments without touching the main codebase.\nCheap to create and delete — Git branching is just updating a tiny file.\nEnable parallel development.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#branches-vs-tags",
    "href": "lec2.html#branches-vs-tags",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.8 5. Branches vs tags",
    "text": "2.8 5. Branches vs tags\n\nBranch → moves as you commit.\nTag → fixed pointer to a commit (used for marking releases).\n\n\n💡 Inside .git/refs/heads/, each branch is just a plain text file storing a commit hash.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#origin-of-the-term",
    "href": "lec2.html#origin-of-the-term",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.11 Origin of the term",
    "text": "2.11 Origin of the term\n\nThe phrase comes from distributed version control (like Git before GitHub’s UI popularized it).\nIf you had changes in your branch/repo and wanted them in the upstream project, you’d contact the maintainer and say:\n\n“Please pull these changes from my branch into yours.”\n\nSo a pull request is literally a request for someone else to pull your commits.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#how-it-works-e.g.-on-github-gitlab-bitbucket",
    "href": "lec2.html#how-it-works-e.g.-on-github-gitlab-bitbucket",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.12 How it works (e.g., on GitHub, GitLab, Bitbucket)",
    "text": "2.12 How it works (e.g., on GitHub, GitLab, Bitbucket)\n\nYou push your branch to your fork or to the remote repository.\nYou open a pull request against the target branch (usually main or develop).\nThe repository maintainers review your code.\nIf accepted, they “pull” your commits into their branch (though under the hood it’s often implemented as a merge or rebase).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#contrast-with-push",
    "href": "lec2.html#contrast-with-push",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.13 Contrast with “push”",
    "text": "2.13 Contrast with “push”\n\nPush: You directly upload commits to a remote branch you have permission to write to.\nPull request: You don’t merge directly — instead, you ask maintainers to pull your changes, review them, and integrate them.\n\nSummary: It’s called a pull request because you’re not pushing your changes into the target branch; you’re asking the project owner/maintainer to pull your branch into theirs.\n\nRecommended (web UI): Navigate to your repo on GitHub → Compare & pull request → base: main, compare: setup/git-lfs. Fill title/description, tag your partner, and create the PR.\nOptional (API): open a PR programmatically from Colab:\n\n# OPTIONAL: Create PR via GitHub API (requires token again)\nfrom getpass import getpass\nimport requests, json\n\ntoken = getpass(\"GitHub token (again, not stored): \")\nheaders = {\"Authorization\": f\"Bearer {token}\",\n           \"Accept\": \"application/vnd.github+json\"}\npayload = {\n    \"title\": \"Setup: .gitignore + Git-LFS + sample Parquet\",\n    \"head\": BRANCH,\n    \"base\": \"main\",\n    \"body\": \"Adds .gitignore, configures Git-LFS for parquet/db/pdf/model files, and commits a sample Parquet for verification.\"\n}\nr = requests.post(f\"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/pulls\",\n                  headers=headers, data=json.dumps(payload))\nprint(\"PR status:\", r.status_code)\ntry:\n    pr_url = r.json()[\"html_url\"]\n    print(\"PR URL:\", pr_url)\nexcept Exception as e:\n    print(\"Response:\", r.text)\ndel token\n\n2.13.1 11) Quick verification checklist\n\ngit lfs ls-files shows data/processed/sample_returns.parquet:\n\n!git lfs ls-files\n\nPR diff shows a small pointer for the Parquet, not raw binary content.\n.gitignore present; no secrets or raw data committed.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#wrapup",
    "href": "lec2.html#wrapup",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.14 Wrap‑up",
    "text": "2.14 Wrap‑up\n\nKeep PRs small and focused; write helpful titles and descriptions.\nDon’t commit secrets or large data. Use .env + .env.example.\nUse LFS selectively—version only small, important binaries (e.g., sample processed sets, posters).\nNext time: Quarto polish (already started) and Unix automation to fetch raw data reproducibly.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#emphasize",
    "href": "lec2.html#emphasize",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.15 Emphasize",
    "text": "2.15 Emphasize\n\nSmall PRs win. Short diffs → fast, focused reviews.\nDon’t commit secrets. .env only; keep .env.example up to date.\nUse LFS sparingly and purposefully—prefer regenerating big raw data.\nColab pushes: use a short‑lived token, and clear outputs after use.\n\nNext session: Quarto reporting polish and pipeline hooks; soon after, Unix automation so make get-data can reproducibly fetch raw data for the unified‑stocks project.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "lec2.html#what-to-emphasize",
    "href": "lec2.html#what-to-emphasize",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.16 What to Emphasize",
    "text": "2.16 What to Emphasize\n\nSmall PRs win. Short diffs → fast, focused reviews.\nDon’t commit secrets. .env only; keep .env.example up to date.\nUse LFS sparingly and purposefully—prefer regenerating big raw data.\nColab pushes: use a short‑lived token, and clear outputs after use.\n\nNext session: Quarto reporting polish and pipeline hooks; soon after, Unix automation so make get-data can reproducibly fetch raw data for the unified‑stocks project.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "13‑week plan (2 × 75‑min per week)\nWeek 1 – Setup, Colab, Git/GitHub\nWeek 2 – Reproducible reporting (Quarto) + RStudio cameo\nWeek 3 – Unix for data work + automation\nWeek 4 – SQL I (schemas, joins)\nWeek 5 – pandas for time series\nWeek 6 – APIs & Web scraping (ethics + caching)\nWeek 7 – Quality: tests, lint, minimal CI\nWeek 8 – Time‑series baselines & backtesting\nWeek 9 – Finance‑specific evaluation & leakage control\nWeek 10 – PyTorch fundamentals\nWeek 11 – Transformers for sequences (tiny GPT)\nWeek 12 – Productivity at scale (lightweight)\nWeek 13 – Communication & showcase",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#week-plan-2-75min-per-week",
    "href": "intro.html#week-plan-2-75min-per-week",
    "title": "Introduction",
    "section": "",
    "text": "Lec A: Local Python + VS Code; Colab basics (GPU, Drive mount, persistence limits), repo cloning in Colab, requirements.txt, seeds.\nLec B: Git essentials, branching, PRs, code review etiquette, .gitignore, Git‑LFS do’s/don’ts (quota pitfalls).\nDeliverable: Team repo with a Colab notebook that runs and logs environment info; one PR merged.\n\n\n\nLec A: Quarto for Python: parameters, caching, citations; publish to GitHub Pages.\nLec B (15–25 min cameo): RStudio + Quarto rendering (so they can read R‑centric docs later), then back to Python.\nDeliverable: Parameterized EDA report (symbol, date range as params).\n\n\n\nLec A: Shell basics (pipes, redirects), grep/sed/awk, find/xargs, regex.\nLec B: Shell scripts, simple Makefile/justfile targets; rsync, quick SSH/tmux tour.\nDeliverable: make get-data and make report run end‑to‑end.\n\n\n\nLec A: SQLite in repo; schema design for OHLCV + metadata; SELECT/JOIN/GROUP BY.\nLec B: Window functions; indices; pandas.read_sql pipelines.\nDeliverable: SQL notebook producing a tidy table ready for modeling.\n\n\n\nLec A: Cleaning, types, missing, merges; groupby, pivot; Parquet I/O.\nLec B: Time‑series ops: resampling, rolling windows, shifting/lagging, calendar effects.\nDeliverable: Cleaned Parquet dataset + feature snapshot.\n\n\n\nLec A: HTTP basics, requests, pagination, auth, retries, backoff; don’t hard‑code keys (python‑dotenv).\nLec B: BeautifulSoup, CSS selectors, robots.txt, throttling; cache raw pulls; persist to SQL/Parquet.\nDeliverable: One external data source ingested with caching & schema checks.\n\n\n\nLec A: pytest (2–3 meaningful tests), data validation (light Pandera or custom checks), logging, type hints.\nLec B: Pre‑commit (black, ruff, nbstripout), GitHub Actions to run tests + lint on PRs (fast jobs only).\nDeliverable: CI badge green; failing test demonstrates leakage prevention or schema guard.\n\n\n\nLec A: Problem framing; horizon, step size; MAE/sMAPE/MASE; rolling‑origin evaluation.\nLec B: Baselines: naive/seasonal‑naive; quick ARIMA/Prophet or sklearn regressor with lags.\nDeliverable: Baseline model card + backtest plot in Quarto.\n\n\n\nLec A: Feature timing & label definition (t+1 returns, multi‑step horizons), survivorship bias, look‑ahead traps, data snooping.\nLec B: Walk‑forward / expanding window, embargoed splits, drift detection; error analysis by regime (volatility bins, bull/bear).\nDeliverable: A robust evaluation plan + revised splits; leakage test added to pytest.\n\n\n\nLec A: Tensors, autograd, datasets/dataloaders for windows; training loop, early stopping; GPU in Colab; mixed precision.\nLec B: A small LSTM/TCN baseline for forecasting; monitoring loss/metrics; save best weights.\nDeliverable: PyTorch baseline surpasses classical baseline on at least one metric.\n\n\n\nLec A: Attention from scratch; tiny char‑level GPT (embeddings, positions, single head → multi‑head), sanity‑check overfitting on toy data.\nLec B: Adapt to time series: window embedding, causal masking, regression head; ablation (context length, heads, dropout) within Colab budget.\nDeliverable: Transformer results + one ablation figure; notes on compute/time.\n\n\n\nLec A: Packaging a small library (src/ layout, pyproject.toml), simple CLI (Typer) for batch inference; config via YAML.\nLec B: Optional FastAPI endpoint demo (local only) + reproducibility audit (fresh‑clone run).\nDeliverable: Tagged release v1.0-rc, CLI can score a held‑out period and write a report.\n\n\n\nLec A: Poster + abstract workshop; tell the error‑analysis story; figure polish; README & model card.\nLec B: In‑class presentations + final feedback; plan for continuing to the Spring symposium (next‑steps backlog).\nDeliverable: Poster draft, 250‑word abstract, and a reproducible repo ready to extend.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#project-spine",
    "href": "intro.html#project-spine",
    "title": "Introduction",
    "section": "Project spine",
    "text": "Project spine\n\nMilestones: W1 repo & env → W3 automated data pipeline → W6 external data → W7 CI green → W8 baselines → W9 robust eval plan → W10 PyTorch baseline → W11 tiny Transformer → W12 release candidate → W13 poster & talk.\nTracking (minimal): log experiments to a simple CSV (results/experiments.csv) and keep a Quarto “lab notebook.”\nData strategy: keep raw data out of Git (use make get-data); store processed Parquet under 100MB if you must commit; otherwise regenerate. Use Git‑LFS only for small, immutable artifacts to avoid quota pain.\nSecrets: .env with python‑dotenv + .env in .gitignore. For Colab, use environment variables or a JSON in Drive (not committed).",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "lec2.html#in-git-checkout--b-the--b-means-create-a-new-branch-before-checking-it-out.",
    "href": "lec2.html#in-git-checkout--b-the--b-means-create-a-new-branch-before-checking-it-out.",
    "title": "2  Session 2 — Git essentials & Git‑LFS",
    "section": "2.9 In git checkout -b, the -b means “create a new branch” before checking it out.",
    "text": "2.9 In git checkout -b, the -b means “create a new branch” before checking it out.\n\n2.9.1 Without -b\ngit checkout branchname\n\nSwitches to an existing branch.\nFails if the branch does not exist.\n\n\n\n\n2.9.2 With -b\ngit checkout -b branchname\n\nTells Git: “make a branch called branchname pointing to the current commit, and then switch to it.”\nFails if the branch already exists.\n\n\n\n\n2.9.3 Example\nIf you’re on main:\ngit checkout -b feature-x\nSteps Git takes:\n\nCreate a new branch pointer feature-x → same commit as main.\nMove HEAD to feature-x (you’re now “on” that branch).\n\n\n💡 In newer Git versions, the same idea is expressed with:\ngit switch -c feature-x   # -c means create\n-b in checkout and -c in switch both mean create.\n\n\n\n2.9.4 Branch & PR etiquette\n\nOne feature/change per branch (small, reviewable diffs).\nCommit messages: imperative mood, short subject line (≤ 72 chars), details in body if needed:\n\nfeat: add git-lfs tracking for parquet\ndocs: add README section on setup\nchore: ignore raw data directory\n\nPR description: what/why, testing notes, checklist. Tag your teammate for review.\n\n\n\n2.9.5 .gitignore must‑haves\n\nSecrets: .env, API keys (never commit).\nLarge/derived artifacts: raw/interim data, logs, cache, compiled assets.\nNotebooks’ checkpoints: .ipynb_checkpoints/.\nOS/editor cruft: .DS_Store (for Mac), Thumbs.db (for Windows), .vscode/.\n\n\n\n2.9.6 Git‑LFS\n\nGit‑LFS = Large File Storage. Keeps pointers in Git; binaries in LFS storage.\nTrack only what’s necessary to version (e.g., small processed Parquet samples, posters/PDFs, small models).\nDo not LFS huge raw data you can re‑download (make get-data).\nQuotas apply on Git hosting—be selective.\n\n\n\n2.9.7 Safe pushes from Colab\n\nUse a fine‑grained PAT limited to a single repo with Contents: Read/Write + Pull requests: Read/Write.\nEnter token via getpass (not stored). Push using a temporary URL (token not saved in git config).\nAfter push, clear cell output.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2 — Git essentials & Git‑LFS</span>"
    ]
  }
]